//? Fetch: запросы на другие сайты
// Если запросить данные с другого сайта, то скорее всего он выдаст ошибку
(async () => {
try {
  await fetch('http://example.com');
} catch(err) {
  console.log(err); // Failed to fetch
}
// ключевым является источник - origin - комбинация домен/порт/протокол
// Отправка на другой источник требует специальных заголовков
// Эта политика называется cors - Cross-Origin Resource Sharing (совмествное использование ресурсов разных источников)


//* Создание CORS
// Против хакеров
// Код одного сайта не может получить доступ к коду другого сайта
// В то время в JS не было сетевых запросов
// Для получения данных использовались разные хитрости

//* Использовали формы

//* Использовали скрипты
// а потом придумали разрешить использовать сторонние скрипты,
// если они сопровождаются соответствующими заголовками


//* Простые запросы
// Есть 2 вида запросов: простые и все остальные
// Простые запросы - удовлетворяющие условиям:
//    1. Простой метод: GET, POST или HEAD
//    2. Простые заголовки:
//        - Accert
//        - Accert-Language
//        - Content-Language
//        - Content-Type со значением application/x-www-form-urlencoded, multipart/form-data или text/plain
// все остальные считаются сложными

// Простой запрос можна делать через form или script без специальных методов

// Перед отправкой запроса браузер посылает специальный предзапрос, который спрашивает страницу:
//  готовла ли она обработать такой запрос
// Если страница явно не отвечает готовностью, то запрос не посылается


//* CORS для простых запросов
// При запросе на другой источник (anywhere.com) браузер в заголовок всегда добавляет Origin
// GET /request
// Host: anywhere.com
// Origin: https://javascript.info

// Сервер может проверить origin и по своему усмотрению добавить заголовок
//  Access-Control-Allow-Origin к ответу
// Этот заголовок должен содержать разрешённый источник или *

// Браузер играет роль посредника:
//  Добавляет к запросу origin
//  Даёт ответ если заголовок Access-Control-Allow-Origin или ошибку, если заголовка нет

// Пример ответа, который разрешает доступ:
// 200 OK
// Content-Type:text/html; charset=UTF-8
// Access-Control-Allow-Origin: *


//* Заголовки простого ответа
// По умолчанию можно получить запрос только к следующим простым заголовкам ответа:
//    Cache-Control
//    Content-Language
//    Content-Type
//    Expires
//    Last-Modified
//    Pragma
//TODO обращение к другим заголовкам выдаст ошибку

//TODO Нет доступа к Content-Length. Для него нужно отдельное разрешение
//* для доступа к другим заголовкам их надо перечислить в Access-Control-Expose-Headers
//  Access-Control-Expose-Headers: Content-Length, API-Key
//  такой ответ даёт доступ к Content-Length и Api-Key


//* Непростые запросы
// Они подразумевают не только использование GET/POST/HEAD, но и любые другие: PUT, PATCH, DELETE и т.д.
// Так как старые сайты могут не понимать непростые запросы, то перед отправкой запроса
//  браузр отправляет простой запрос для уточнения возможности обработать непростой запрос

// Предварительный запрос использует метод OPTIONS
// У него нет теля, но есть 2 заголовка
//    Access-Control-Request-Method - содержит HTTP-метод непростого запроса
//    Access-Control-Request-Headers - содержит список непростых заголовков

// Если сервер согласен обработать запрос, то он должен вернуть статус 200 без тела и с 2 заголовками
//    Access-Control-Allow-Method - и через запятую допустимые методы
//    Access-Control-Allow-Headers - и через запятую допустимые заголовки

// Дополнительно может содеражться заголовок Access-Control-Max-Age,
// который содержит количество секунд, которое браузер может посылать аналогичный запрос
// без использования предзапроса
const response = await fetch('https://site.com/service.json', {
  method: 'PATCH',
  headers: {
    'Content-Type': 'aplication/json',
    'API-Key': 'secret'
  }
})
console.log(response.json())

//TODO предзапросы осуществляются невидимо для JS


//* Авторизационные данные
// Запрос на другой источник по умолчанию не содержит данных авторизации (credentails)
// Обычно все запросы содержат куки этого домена, но JS - исключение
// fetch не содержит кукм даже самого домена

// Это потому, что запрос с ними даёт больше свободы. А сайт не обязательно может доверять скрипту
//  Ведь он может действовать от имени пользователя без его ведома

// Для включения авторизационных данных запрос должен содержать credentails: 'include'
await fetch('http://another.com', {
  credentials: 'include'
})
// если сайт согласен, то он должен ответить Access-Control-Allow-Credentails: true
// вместе с другими заголовками
//TODO в таком ответе у Access-Control-Allow-Origin не может содержаться *
// сайт точно должен указать, кто может ему отправить такой запрос























})()