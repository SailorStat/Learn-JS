//? IndexedDB
//* IidexedDB - более мощная база данных, чем localStorage
//    доступно несколько типов ключей, и почти все типы значений
//    поддерживает транзакции для надёжности
//    поддерживает индексы и запросы в диапозоне ключей
//    позволяет хранить больше данных

// Обычно эти можности занчительно больше, чем надо. Достаточно и localStorage
// IndexedBD обычно используется для офлайн приложений


//* Открыть базу данных
// const openRequest = indexedDB.open(name, version)
//    name - название базы данных, строка
//    version - версия базы данных, положительное целое число (по умолчанию 1)

// У нас может быть большое количество баз данных с разными именами,
//    но все они существуют в рамках источника

// После открытия необходимо назначить обработчкии событий для объекта openRequest
//    success - база данных готова к работе, готов "объект базы данных" openRequest.result,
//        его следует использовать для дальнейших вызовов
//    error - не удалось открыть базу данных
//    upgradeneeded - база данных открыта, но уже устарела

// IndexedDB имеет встроенный механизм "версионирования схемы",
//    который отсутствует в серверных базах данных

// В отличие от серверных баз данных, IndexedDB работает на стороне клиента в браузере, куда нет доступа
// Когда выходит новая версия, нам надо обновить базу данных
// Если локальная версия базы данных меньше, чем в open, то срабоатет событие upgraadeneeded,
//    и мы можем сравнить версии и по мере необходимости обновить структуры
// Также событие сработает, если базы данных ещё не существует,
//    так что в этом обработчике можем выполнить инициализацию

// При первой публикации приложения мы открываем базу данных с версией 1
//    и выполняем инициализацию в обработчике upgradeneeded
{
  const openRequest = indexedDB.open('store', 1)

  openRequest.onupgradeneeded = () => {
    // cрабатывает, если у клиента нет базы данных
    // ...выполнить инициализацию
  }

  openRequest.onerror = () => {
    console.error(`Error`, openRequest.error)
  }

  openRequest.onsuccess = () => {
    const db = openRequest.result
    // продолжаем работу с db
  }
}

// Когда публикуем вторую версию
{
  const openRequest = indexedDB.open('store', 2)

  // проверить существование базы данных, обновить при необходимости
  openRequest.onupgradeneeded = () => {
    // версия базы данных меньше 2
    const db = openRequest.result
    switch(db.version) {
      case 0:
        // версия 0 означает, что на клиенте нет базы данных
        // выполнить инициализацию
      case 1:
        // на клиенте версия базы данных 1
        // обновить
    }
  }
}


//* const deleteRequest = indexedDB.deleteDatabase(name)
// deleteRequest.onsuccess/onerror отслеживают результат


//* Проблема парарлельного обновления
// Если посетитель открыл вкладку в старой версии, а потом ещё одну, которая уже в новой версии,
//    то если мы не разрвёём соединение с 1 версией, то у 2 возникнет событие blocked вместо success
// Чтобы этого избежать, нужно разорвать соединение с 1 версией, обнаружив событие versionchange
//    Нужно предложить перезагрузить страницу
{
  const openRequest = indexedDB.open('store', 2)

  openRequest.onupgradeneeded = () => {
    // код из прошлого примера
  }

  openRequest.onerror = () {
    // код прошлого примера
  }

  openRequest.onsuccess = () => {
    const db = openRequest.result

    db.onversionchange = () => {
      db.close()
      alert('Вышло обновление, перезагрузите страницу')
    }

    // база данных доступна, как обхект db
  }

  openRequest.onblocked = () => {
    // есть другое соединение к той же базе
    // и оно не было закрыто после срабатывания db.onversionchange
  }
}
// Здесь мы делаем 2 вещи:
//    1. Добавляем обработчик db.onversionchange после успешного открытия базы,
//        чтобы узнать о попытке параллельного обновления
//    2. Добавляем обработчик openRequest.onblocked для ситуаций, когда старое соединение не было закрыто.
//        Такое не произойдёт, если мы его закроем в db.onversionchange

// Также мы можем более мягко закрыть соединение в db.onversionchange,
//    предложив пользователю сохранить данные
// Новое обновляющее соединение будет заблокировано сразу после того.
//    как обработчик db.onversionchange завершитсяя, не закрыв соединение,
//    и мы можем попросить в новой вкладке посетителя закрыть старые вкладки (до обновления)

// Такое происходит редко, но мы должны его как-то обрабатывать,
//    хотя бы добавить обработчик onblocked, чтобы скрипт не умирал, дивляя посетителя


//* Хранилище объектов
// Чтобы сохранить в IndexedDB, нужно хранилище объектов
// Хранилище объектов - основная концепция IndexedDB. В других базах это таблицы или коллекции
// В базе может быть много хранилищ: для пользователей, для товаров и т.д.

// Несмотря на название, в хранилище объектов могут храниться примитивы
//    И даже сложные объекты

// IndexedDB использвет стандартный алгоритм сериализации для клонирования и хранения объекта
//    Как JSON.stringify, но более мощный, способный на гораздо больше типов
//    Но нельзя сохранить циклические ссылки

// Каждому значению в хранилище должен соответствовать уникальный ключ
// Ключ должен быть один из типов: number, date, string, binary или array

// Создание хранилища объектов
// db.createObjectStore(name [, keyOptions])
//    name - название хранилища
//    keyOptions - объект со свойствами
//        keyPath - путь к свойству объекта, которое IndexedDB будет использовать в качестве ключа,
//            например id
//        autoincrement - при true ключ будет создаваться автоматически для новых объектов,
//            как постоянно увеличивающееся число
// Если при создании объекта не указать keyOptions,
//    то нам потребуется явно указать ключ позже при сохранении объекта
// Например, это хранилище объектов использует свойство id, как ключ:
//    db.createObjectStore('books', {keyPath: 'id'})